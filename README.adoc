= Jakarta NoSQL
:toc: auto

ifndef::imagesdir[:imagesdir: spec/src/main/asciidoc/images]
image::jakarta_ee_logo_schooner_color_stacked_default.png[Jakarta NoSQL logo,align=center, width=25%, height=25%]

== Introduction

Jakarta NoSQL is a comprehensive framework designed to simplify the integration of Java applications with various NoSQL databases. By providing a unified API and a set of powerful annotations, Jakarta NoSQL enables developers to seamlessly work with different NoSQL data stores while maintaining flexibility and productivity.

== Goals

* Increase productivity performing common NoSQL operations.
* Rich Object Mapping integrated.
* Java-based Query and Fluent-API.
* It is designed to work with various NoSQL databases and can quickly adapt to support new types and behaviors through extensions.
* Annotation-oriented using Jakarta Persistence-like naming when it makes sense.

== One Mapping API to Multiples NoSQL Databases

Jakarta NoSQL provides one API for each NoSQL database type. However, it incorporates the same annotations from the Jakarta Persistence specification and heritage Java Persistence Architecture (JPA) to map Java objects. Therefore, with just these annotations that look like JPA, there is support for more than twenty NoSQL databases.

[source,java]
----
@Entity
public class Car {

    @Id
    private Long id;
    @Column
    private String name;
    @Column
    private CarType type;
 //...
}
----

=== Annotations

The annotations from the Mapping API will look familiar to Jakarta Persistence developers:

[cols="2"]
|===
| Annotation | Description
| `@Entity` | Specifies that the class is an entity. This annotation is applied to the entity class.
| `@Id` | Specifies the primary key of an entity.
| `@Column` | Specifies the mapped column for a persistent property or field.
| `@MappedSuperclass` | Specifies a class whose mapping information is applied to entities that inherit from it.
| `@Embeddable` | Declares a class whose instances are stored as an intrinsic part of an owning entity, sharing the identity of the entity.
| `@Inheritance` | Specifies the inheritance mapping strategy for the entity class hierarchy.
| `@DiscriminatorColumn` | Specifies the discriminator column for the mapping strategy.
| `@DiscriminatorValue` | Specifies the value of the discriminator column for the annotated entity type.
| `@Convert` | Specifies how the values of a field or property are converted to a basic type or a type that can be persisted by a persistence provider.
|===

These annotations provide a powerful toolkit for defining and mapping entities in NoSQL databases, analogous to their counterparts in Jakarta Persistence.

=== Template

The `Template` interface is the central entry point for interacting with a NoSQL database in Jakarta NoSQL. It provides a consistent, high-level API for performing common persistence operations such as `insert`, `update`, `delete`, and `query`.

Jakarta NoSQL supports multiple interaction styles through the `Template`, including:

* Basic CRUD operations
* Fluent-style query builders
* String-based queries with support for projections

==== Basic Operations

Once you’ve annotated your entity, you can perform basic operations like insert, find, and delete using the `Template` instance.

[source,java]
----
@Inject
Template template;

Car ferrari = Car.builder()
        .id(1L)
        .name("Ferrari")
        .type(CarType.SPORT)
        .build();

template.insert(ferrari);

Optional<Car> car = template.find(Car.class, 1L);

template.delete(Car.class, 1L);
----

These operations work consistently across different NoSQL types (Key-Value, Document, Column, Graph), and provide an abstraction over provider-specific drivers.

==== Fluent API

Jakarta NoSQL provides a fluent API for dynamic query construction, enabling you to perform more expressive filtering and deletion operations programmatically — without writing string-based queries.

*Select example:*

[source,java]
----
List<Car> sportsCars = template.select(Car.class)
    .where("type").eq(CarType.SPORT)
    .orderBy("name")
    .result();
----

*Delete example:*

[source,java]
----
template.delete(Car.class)
    .where("type").eq(CarType.CLASSIC)
    .execute();
----

This style promotes type safety and cleaner code, especially in dynamic or reusable query scenarios.

==== Typed Queries and Projections

You can also execute string-based queries using the Jakarta Query Core language. The `Template` offers two approaches:

* `query(String)` — generic query for update, delete, or select
* `typedQuery(String, Class<T>)` — allows result mapping to entity or projection classes

===== Select with parameters

[source,java]
----
List<Car> cars = template.query("FROM Car WHERE type = :type", Car.class)
                         .bind("type", CarType.SPORT)
                         .result();
----

===== Delete with parameters

[source,java]
----
template.query("DELETE FROM Car WHERE type = :type")
        .bind("type", CarType.CLASSIC)
        .executeUpdate();
----

===== Using projections with records

Projections allow partial mapping of query results into lightweight records. This improves performance and simplifies read models.

[source,java]
----
@Projection
public record TechCarView(String name, CarType type) {}

List<TechCarView> cars = template
    .typedQuery("FROM Car WHERE type = 'SPORT'", TechCarView.class)
    .result();
----

You may also omit the `FROM` clause by defining the entity in the `@Projection(from = Car.class)` annotation.

[source,java]
----
@Projection(from = Car.class)
public record BudgetCar(String name, double price) {}

List<BudgetCar> cheapCars = template
    .typedQuery("WHERE price < 100", BudgetCar.class)
    .result();
----

===== Nested attributes with `@Column`

When working with associated or embedded objects, use the `@Column("path.to.property")` annotation to flatten nested results.

[source,java]
----
@Projection(from = Order.class)
public record OrderSummary(
    String id,
    @Column("customer.name") String customerName,
    @Column("customer.address.city") String city
) {}
----

This approach is *read-only* and is designed for flexible querying — not persistence.

=== Maven dependency

[source,xml]
----
<dependency>
    <groupId>jakarta.nosql</groupId>
    <artifactId>jakarta.nosql-api</artifactId>
    <version>1.0.1</version>
</dependency>
----

=== More Information

To learn more, please refer to the https://www.jnosql.org/spec/[reference documentation], and https://www.jnosql.org/javadoc/[JavaDocs].

== Code of Conduct

This project is governed by the Eclipse Foundation of Conduct. By participating, you are expected to uphold this code of conduct. Please report unacceptable behavior to codeofconduct@eclipse.org.

== Getting Help

Having trouble with Jakarta NoSQL? We’d love to help!

Please report any bugs, concerns or questions with Jakarta NoSQL to https://github.com/jakartaee/nosql.

== Building from Source

You don't need to build from source to use the project, but should you be interested in doing so, you can build it using Maven and Java 21 or higher.

[source, Bash]
----
mvn clean install
----
