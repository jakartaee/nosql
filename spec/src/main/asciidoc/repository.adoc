// Copyright (c) 2019 Otavio Santana and others
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

=== Repository

In addition to a template class, the Mapping API has the Repository. This interface helps the Entity repository to save, update, delete and retrieve information. To use Repository, you just need to create a new interface that extends the *Repository*.

[source,java]
----
interface PersonRepository extends Repository<Person, String> {

}
----

The qualifier is mandatory to define the database type that will be used at the injection point moment.

[source,java]
----
@Inject
@Database(DatabaseType.DOCUMENT)
private PersonRepository documentRepository;

@Inject
@Database(DatabaseType.COLUMN)
private PersonRepository columnRepository;

@Inject
@Database(DatabaseType.KEY_VALUE)
private PersonRepository keyValueRepository;

@Inject
@Database(DatabaseType.GRAPH)
private PersonRepository graphRepository;
----

And then, make any manager class (*ColumnFamilyManager*, *DocumentCollectionManager*, *BucketManager*, and *Graph*) eligible to CDI defining a method with Produces annotation.

[source,java]
----
@Produces
public DocumentCollectionManager getManager() {
  DocumentCollectionManager manager = //instance;
  return manager;
}

@Produces
public ColumnFamilyManager getManager() {
  ColumnFamilyManager manager = //instance;
  return manager;
}

@Produces
public BucketManager getManager() {
  BucketManager manager = //instance;
  return manager;
}

@Produces
public Graph getGraph() {
  Graph graph = //instance;
  return graph;
}
----

To work with multiple databases, you can use qualifiers:

[source,java]
----
@Inject
@Database(value = DatabaseType.DOCUMENT , provider = "databaseA")
private PersonRepository documentRepositoryA;

@Inject
@Database(value = DatabaseType.DOCUMENT , provider = "databaseB")
private PersonRepository documentRepositoryB;

@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
private PersonRepository columnRepositoryA;

@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
private PersonRepository columnRepositoryB;

@Inject
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseA")
private UserRepository userRepositoryA;

@Inject
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseB")
private UserRepository userRepositoryB;

@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
private PersonRepository graphRepositoryA;

@Inject
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
private PersonRepository graphRepositoryB;

//producers methods
@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
public ColumnFamilyManager getColumnFamilyManagerA() {
  ColumnFamilyManager manager = //instance;
  return manager;
}

@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
public ColumnFamilyManager getColumnFamilyManagerB() {
  ColumnFamilyManager manager = //instance;
  return manager;
}

@Produces
@Database(value = DatabaseType.DOCUMENT, provider = "databaseA")
public DocumentCollectionManager getDocumentCollectionManagerA() {
  DocumentCollectionManager manager = //instance;
  return manager;
}

@Produces
@Database(value = DatabaseType.DOCUMENT, provider = "databaseB")
public DocumentCollectionManager DocumentCollectionManagerB() {
  DocumentCollectionManager manager = //instance;
  return manager;
}

@Produces
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseA")
public BucketManager getBucket() {
    BucketManager manager = //instance;
    return manager;
}

@Produces
@Database(value = DatabaseType.KEY_VALUE, provider = "databaseB")
public BucketManager getBucketB() {
    BucketManager manager = //instance;
    return manager;
}

@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseA")
public Graph getGraph() {
    Graph graph = //instance;
    return graph;
}

@Produces
@Database(value = DatabaseType.GRAPH, provider = "databaseB")
public Graph getGraphB() {
    Graph graph = //instance;
    return graph;
}
----

So, Jakarta NoSQL will inject automatically.

[source,java]
----
PersonRepository repository = //instance;

Person person = new Person();
person.setNickname("diana");
person.setName("Diana Goodness");

List<Person> people = Collections.singletonList(person);

repository.save(person);
repository.save(people);
----


==== Query by method

The Repository also has a method query from the method name. These are the keywords:

* *findBy*: The prefix to find some information.
* *deleteBy*: The prefix to delete some information.

Also, the operators:

* And
* Or
* Between
* LessThan
* GreaterThan
* LessThanEqual
* GreaterThanEqual
* Like
* In
* OrderBy
* OrderBy\_\_\_\_Desc
* OrderBy\_\_\_\_\_ASC

[source,java]
----
interface PersonRepository extends Repository<Person, Long> {

    List<Person> findByAddress(String address);

    Stream<Person> findByName(String name);

    Stream<Person> findByNameOrderByNameAsc(String name);

    Optional<Person> findByNickname(String nickname);

    void deleteByNickName(String nickname);
}
----

Using these keywords, Mapping will create the queries.

===== Special Parameters

In addition to the use of use the query method, the repository has support to a special instance at the parameters in a method:


* `Pagination`: This parameter enables the resource of pagination at a repository.
* `Sort`: It appends sort in the query dynamically if the query method has the `OderBy` keyword. This parameter will add the sort after the sort information from the method.
* `Sorts`: It is a group of a sort, therefore, it appends one or more sort dynamically.


[source,java]
----
   interface PersonRepository extends Repository<Person, Long> {

        List<Person> findAll(Pagination pagination);

        List<Person> findByName(String name, Sort sort);

        List<Person> findByAgeGreaterThan(Integer age, Sorts sorts);
    }
----

This resource allows pagination and a dynamical sort in a smooth way.

[source,java]
----
PersonRepository personRepository = //instance;
Sort sort = Sort.asc("name");
Sorts sorts = Sorts.sorts().asc("name").desc("age");
Pagination pagination = Pagination.page(1).size(10);

List<Person> all = personRepository.findAll(pagination);//findAll by pagination
List<Person> byName = personRepository.findByName("Ada", sort);//find by name order by name asc
List<Person> byAgeGreaterThan = personRepository.findByAgeGreaterThan(22, sorts);//find age greater than 22 sort name asc then age desc
----

WARNING: All these special instances must be at the end, thus after the parameters that will be used at a query.


==== Using Query annotation

The Repository interface contains all the trivial methods shared among the NoSQL implementations that a developer does not need to care. Also, there is a query method that does query based on the method name. Equally important, there are two new annotations: The Query and param, that defines the statement and set the values in the query respectively.

[source,java]
----
public interface PersonRepository extends Repository<Person, Long> {
    @Query("select * from Person")
    Optional<Person> findByQuery();

    @Query("select * from Person where id = @id")
    Optional<Person> findByQuery(@Param("id") String id);
}
----

IMPORTANT: Remember, when a developer defines who that repository will be implemented from the CDI qualifier, the query will be executed to that defined type, given that, gremlin to Graph, Jakarta NoSQL key to key-value and so on.

==== How to Create Repository implementation programmatically

The Mapping API has support to create Repository programmatically to each NoSQL type, so there are *ColumnRepositoryProducer*, *DocumentRepositoryProducer*, *KeyValueRepositoryProducer*, *GraphRepositoryProducer* to column, document, key-value, graph repository implementation respectively. Each producer needs both the repository class and the manager instance to return a repository instance.


.Graph repository producer
[source,java]
----
@Inject
private GraphRepositoryProducer producer;

public void anyMethod() {
    Graph graph = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, graph);
}
----

.Key-value repository producer
[source,java]
----
@Inject
private KeyValueRepositoryProducer producer;

public void anyMethod() {
    BucketManager manager = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, manager);
}
----

.Column repository producer
[source,java]
----
@Inject
private ColumnRepositoryProducer producer;

public void anyMethod() {
    DocumentCollectionManager manager = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, graph);
}
----

.Document repository producer
[source,java]
----
@Inject
private DocumentRepositoryProducer producer;

public void anyMethod() {
    DocumentCollectionManager manager = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, graph);
}
----


[source,java]
----
@Inject
private ColumnRepositoryProducer producer;

public void anyMethod() {
    ColumnFamilyManager manager = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, manager);
}
----

[source,java]
----
@Inject
private DocumentRepositoryProducer producer;

public void anyMethod() {
    DocumentCollectionManager manager = //instance;
    PersonRepository personRepository = producer.get(PersonRepository.class, manager);
}
----